Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@sentry/core");
const utils_1 = require("@sentry/utils");
const sdk_1 = require("../sdk");
const backend_1 = require("./backend");
const context_1 = require("./context");
const normalize_1 = require("./normalize");
/** SDK version used in every event. */
// tslint:disable-next-line
exports.SDK_VERSION = require('../../package.json').version;
/** Frontend implementation for Electron renderer backends. */
class MainClient extends core_1.BaseClient {
    /**
     * Creates a new Electron SDK instance.
     * @param options Configuration options for this SDK.
     */
    constructor(options) {
        super(backend_1.MainBackend, options);
    }
    /**
     * @inheritDoc
     */
    _prepareEvent(event, scope, hint) {
        event.platform = event.platform || 'node';
        event.sdk = Object.assign(Object.assign({}, event.sdk), { name: sdk_1.SDK_NAME, packages: [
                ...((event.sdk && event.sdk.packages) || []),
                {
                    name: 'npm:@sentry/electron',
                    version: exports.SDK_VERSION,
                },
            ], version: exports.SDK_VERSION });
        return super._prepareEvent(event, scope, hint).then((filledEvent) => new utils_1.SyncPromise((resolve) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (filledEvent) {
                resolve(normalize_1.normalizeEvent(yield context_1.addEventDefaults(this._options.appName, filledEvent)));
            }
            else {
                resolve(filledEvent);
            }
        })).then((e) => e));
    }
    /**
     * Uploads a native crash dump (Minidump) to Sentry.
     *
     * @param path The relative or absolute path to the minidump.
     * @param event Optional event payload to attach to the minidump.
     * @param scope Optional SDK scope used to upload.
     */
    captureMinidump(path, event = {}, scope) {
        let eventId;
        this._processing = true;
        event.tags = Object.assign({ event_type: 'native' }, event.tags);
        // We are not calling _processEvent here since we do not have beforeSend for minidump crashes
        this._prepareEvent(event, scope, undefined).then(finalEvent => {
            if (finalEvent) {
                eventId = finalEvent && finalEvent.event_id;
                this._getBackend().uploadMinidump(path, finalEvent);
            }
            this._processing = false;
        }, reason => {
            utils_1.logger.error(reason);
            this._processing = false;
        });
        return eventId;
    }
    /**
     * @inheritDoc
     */
    captureEvent(event, hint, scope) {
        event.tags = Object.assign({ event_type: 'javascript' }, event.tags);
        return super.captureEvent(event, hint, scope);
    }
    /**
     * Does nothing in main/node
     */
    showReportDialog(_) {
        // noop
    }
}
exports.MainClient = MainClient;
//# sourceMappingURL=client.js.map