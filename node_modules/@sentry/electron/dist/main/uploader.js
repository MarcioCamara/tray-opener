Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const utils_1 = require("@sentry/utils");
const electron_fetch_1 = require("electron-fetch");
const FormData = require("form-data");
const fs = require("fs");
const path_1 = require("path");
const util_1 = require("util");
const fs_1 = require("./fs");
const store_1 = require("./store");
const readdir = util_1.promisify(fs.readdir);
const rename = util_1.promisify(fs.rename);
const stat = util_1.promisify(fs.stat);
const unlink = util_1.promisify(fs.unlink);
/** Status code returned by Sentry to retry event submission later. */
const CODE_RETRY = 429;
/** Maximum number of days to keep a minidump before deleting it. */
const MAX_AGE = 30;
/** Maximum number of requests that we store/queue if something goes wrong. */
const MAX_REQUESTS_COUNT = 10;
/**
 * A service that discovers Minidump crash reports and uploads them to Sentry.
 */
class MinidumpUploader {
    /**
     * Creates a new uploader instance.
     *
     * @param dsn The Sentry DSN.
     * @param crashesDirectory The directory Electron stores crashes in.
     * @param cacheDirectory A persistent directory to cache minidumps.
     */
    constructor(dsn, crashesDirectory, cacheDirectory) {
        const crashpadWindows = process.platform === 'win32' && parseInt(process.versions.electron.split('.')[0], 10) >= 6;
        this._type = process.platform === 'darwin' || crashpadWindows ? 'crashpad' : 'breakpad';
        this._crashpadSubDirectory = process.platform === 'darwin' ? 'completed' : 'reports';
        this._knownPaths = [];
        this._url = MinidumpUploader.minidumpUrlFromDsn(dsn);
        this._crashesDirectory = crashesDirectory;
        this._cacheDirectory = cacheDirectory;
        this._queue = new store_1.Store(this._cacheDirectory, 'queue', []);
    }
    /**
     * Returns the minidump endpoint in Sentry
     * @param dsn Dsn
     */
    static minidumpUrlFromDsn(dsn) {
        const { host, path, projectId, port, protocol, user } = dsn;
        return `${protocol}://${host}${port !== '' ? `:${port}` : ''}${path !== '' ? `/${path}` : ''}/api/${projectId}/minidump?sentry_key=${user}`;
    }
    /**
     * Uploads a minidump file to Sentry.
     *
     * @param path Absolute path to the minidump file.
     * @param event Event data to attach to the minidump.
     * @returns A promise that resolves when the upload is complete.
     */
    uploadMinidump(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            utils_1.logger.log('Uploading minidump', request.path);
            try {
                const body = new FormData();
                body.append('upload_file_minidump', fs.createReadStream(request.path));
                body.append('sentry', JSON.stringify(request.event));
                const response = yield electron_fetch_1.default(this._url, { method: 'POST', body });
                // Too many requests, so we queue the event and send it later
                if (response.status === CODE_RETRY) {
                    yield this._queueMinidump(request);
                }
                // We either succeeded or something went horribly wrong. Either way, we
                // can remove the minidump file.
                try {
                    yield unlink(request.path);
                }
                catch (e) {
                    utils_1.logger.warn('Could not delete', request.path);
                }
                // Forget this minidump in all caches
                // tslint:disable-next-line: strict-comparisons
                this._queue.update(queued => queued.filter(stored => stored !== request));
                this._knownPaths.splice(this._knownPaths.indexOf(request.path), 1);
                // If we were successful, we can try to flush the remaining queue
                if (response.ok) {
                    yield this.flushQueue();
                }
            }
            catch (err) {
                utils_1.logger.warn('Failed to upload minidump', err);
                // User's internet connection was down so we queue it as well
                const error = err ? err : { code: '' };
                if (error.code === 'ENOTFOUND') {
                    yield this._queueMinidump(request);
                }
            }
        });
    }
    /**
     * Helper to filter an array with asynchronous callbacks.
     *
     * @param array An array containing items to filter.
     * @param predicate An async predicate evaluated on every item.
     * @param thisArg Optional value passed as "this" into the callback.
     * @returns An array containing only values where the callback returned true.
     */
    _filterAsync(array, predicate, thisArg) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const verdicts = yield Promise.all(array.map(predicate, thisArg));
            return array.filter((_, index) => verdicts[index]);
        });
    }
    /**
     * Searches for new, unknown minidump files in the crash directory.
     * @returns A promise that resolves to absolute paths of those dumps.
     */
    getNewMinidumps() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const minidumps = this._type === 'crashpad' ? yield this._scanCrashpadFolder() : yield this._scanBreakpadFolder();
            utils_1.logger.log(`Found ${minidumps.length} minidumps`);
            const oldestMs = new Date().getTime() - MAX_AGE * 24 * 3600 * 1000;
            return this._filterAsync(minidumps, (path) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                // Skip files that we have seen before
                if (this._knownPaths.indexOf(path) >= 0) {
                    return false;
                }
                // Lock this minidump until we have uploaded it or an error occurs and we
                // remove it from the file system.
                this._knownPaths.push(path);
                // We do not want to upload minidumps that have been generated before a
                // certain threshold. Those old files can be deleted immediately.
                const stats = yield stat(path);
                if (stats.birthtimeMs < oldestMs) {
                    try {
                        yield unlink(path);
                    }
                    catch (e) {
                        utils_1.logger.warn('Could not delete', path);
                    }
                    this._knownPaths.splice(this._knownPaths.indexOf(path), 1);
                    return false;
                }
                return true;
            }));
        });
    }
    /** Flushes locally cached minidumps from the queue. */
    flushQueue() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield Promise.all(this._queue.get().map((request) => tslib_1.__awaiter(this, void 0, void 0, function* () { return this.uploadMinidump(request); })));
        });
    }
    /** Scans the Crashpad directory structure for minidump files. */
    _scanCrashpadFolder() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Crashpad moves minidump files directly into the 'completed' or 'reports' folder. We can
            // load them from there, upload to the server, and then delete it.
            const dumpDirectory = path_1.join(this._crashesDirectory, this._crashpadSubDirectory);
            const files = yield readdir(dumpDirectory);
            return files.filter(file => file.endsWith('.dmp')).map(file => path_1.join(dumpDirectory, file));
        });
    }
    /** Scans the Breakpad directory structure for minidump files. */
    _scanBreakpadFolder() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Breakpad stores all minidump files along with a metadata file directly in
            // the crashes directory.
            const files = yield readdir(this._crashesDirectory);
            // Remove all metadata files and forget about them.
            // tslint:disable-next-line: no-floating-promises
            Promise.all(files
                .filter(file => file.endsWith('.txt') && !file.endsWith('log.txt'))
                .map((file) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const path = path_1.join(this._crashesDirectory, file);
                try {
                    yield unlink(path);
                }
                catch (e) {
                    utils_1.logger.warn('Could not delete', path);
                }
            })));
            return files.filter(file => file.endsWith('.dmp')).map(file => path_1.join(this._crashesDirectory, file));
        });
    }
    /**
     * Enqueues a minidump with event information for later upload.
     * @param request The request containing a minidump and event info.
     */
    _queueMinidump(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const filename = path_1.basename(request.path);
            // Only enqueue if this minidump hasn't been enqueued before. Compare the
            // filename instead of the full path, because we will move the file to a
            // temporary location later on.
            if (this._queue.get().some(req => path_1.basename(req.path) === filename)) {
                return;
            }
            // Move the minidump file to a separate cache directory and enqueue it. Even
            // if the Electron CrashReporter's cache directory gets wiped or changes,
            // this will allow us to retry uploading the file later.
            const queuePath = path_1.join(this._cacheDirectory, filename);
            yield fs_1.mkdirp(this._cacheDirectory);
            yield rename(request.path, queuePath);
            // Remove stale minidumps in case we go over limit. Note that we have to
            // re-fetch the queue as it might have changed in the meanwhile. It is
            // important to store the queue value again immediately to avoid phantom
            // reads.
            const requests = [...this._queue.get(), Object.assign(Object.assign({}, request), { path: queuePath })];
            const stale = requests.splice(-MAX_REQUESTS_COUNT);
            this._queue.set(requests);
            yield Promise.all(stale.map((req) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                try {
                    yield unlink(req.path);
                }
                catch (e) {
                    utils_1.logger.warn('Could not delete', req.path);
                }
            })));
        });
    }
}
exports.MinidumpUploader = MinidumpUploader;
//# sourceMappingURL=uploader.js.map