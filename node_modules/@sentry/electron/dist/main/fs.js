Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs_1 = require("fs");
const path_1 = require("path");
const _0777 = parseInt('0777', 8);
/**
 * Asynchronously reads given files content.
 *
 * @param path A relative or absolute path to the file
 * @returns A Promise that resolves when the file has been read.
 */
function readFileAsync(path) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        // We cannot use util.promisify here because that was only introduced in Node
        // 8 and we need to support older Node versions.
        return new Promise((res, reject) => {
            fs_1.readFile(path, 'utf8', (err, data) => {
                if (err) {
                    reject(err);
                }
                else {
                    res(data);
                }
            });
        });
    });
}
exports.readFileAsync = readFileAsync;
/**
 * Asynchronously creates the given directory.
 *
 * @param path A relative or absolute path to the directory.
 * @param mode The permission mode.
 * @returns A Promise that resolves when the path has been created.
 */
function mkdirAsync(path, mode) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        // We cannot use util.promisify here because that was only introduced in Node
        // 8 and we need to support older Node versions.
        return new Promise((res, reject) => {
            fs_1.mkdir(path, mode, err => {
                if (err) {
                    reject(err);
                }
                else {
                    res();
                }
            });
        });
    });
}
/**
 * Recursively creates the given path.
 *
 * @param path A relative or absolute path to create.
 * @returns A Promise that resolves when the path has been created.
 */
function mkdirp(path) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        // tslint:disable-next-line:no-bitwise
        const mode = _0777 & ~process.umask();
        const realPath = path_1.resolve(path);
        try {
            return mkdirAsync(realPath, mode);
        }
        catch (err) {
            const error = err;
            if (error && error.code === 'ENOENT') {
                yield mkdirp(path_1.dirname(realPath));
                return mkdirAsync(realPath, mode);
            }
            try {
                if (!fs_1.statSync(realPath).isDirectory()) {
                    throw err;
                }
            }
            catch (_) {
                throw err;
            }
        }
    });
}
exports.mkdirp = mkdirp;
/**
 * Synchronous version of {@link mkdirp}.
 *
 * @param path A relative or absolute path to create.
 */
function mkdirpSync(path) {
    // tslint:disable-next-line:no-bitwise
    const mode = _0777 & ~process.umask();
    const realPath = path_1.resolve(path);
    try {
        fs_1.mkdirSync(realPath, mode);
    }
    catch (err) {
        const error = err;
        if (error && error.code === 'ENOENT') {
            mkdirpSync(path_1.dirname(realPath));
            fs_1.mkdirSync(realPath, mode);
        }
        else {
            try {
                if (!fs_1.statSync(realPath).isDirectory()) {
                    throw err;
                }
            }
            catch (_) {
                throw err;
            }
        }
    }
}
exports.mkdirpSync = mkdirpSync;
//# sourceMappingURL=fs.js.map