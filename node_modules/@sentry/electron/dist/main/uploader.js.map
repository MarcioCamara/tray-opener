{"version":3,"file":"uploader.js","sourceRoot":"","sources":["../../src/main/uploader.ts"],"names":[],"mappings":"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","sourcesContent":["import { Event } from '@sentry/types';\nimport { Dsn, logger } from '@sentry/utils';\nimport fetch from 'electron-fetch';\nimport FormData = require('form-data');\nimport * as fs from 'fs';\nimport { basename, join } from 'path';\nimport { promisify } from 'util';\n\nimport { mkdirp } from './fs';\nimport { Store } from './store';\n\nconst readdir = promisify(fs.readdir);\nconst rename = promisify(fs.rename);\nconst stat = promisify(fs.stat);\nconst unlink = promisify(fs.unlink);\n\n/** Status code returned by Sentry to retry event submission later. */\nconst CODE_RETRY = 429;\n\n/** Maximum number of days to keep a minidump before deleting it. */\nconst MAX_AGE = 30;\n\n/** Maximum number of requests that we store/queue if something goes wrong. */\nconst MAX_REQUESTS_COUNT = 10;\n\n/** Supported types of Electron CrashReporters. */\ntype CrashReporterType = 'crashpad' | 'breakpad';\n\n/**\n * Payload for a minidump request comprising a persistent file system path and\n * event metadata.\n */\nexport interface MinidumpRequest {\n  /** Path to the minidump file. */\n  path: string;\n  /** Associated event data. */\n  event: Event;\n}\n\n/**\n * A service that discovers Minidump crash reports and uploads them to Sentry.\n */\nexport class MinidumpUploader {\n  /** The minidump ingestion endpoint URL. */\n  private readonly _url: string;\n\n  /** The type of the Electron CrashReporter used to search for Minidumps. */\n  private readonly _type: CrashReporterType;\n\n  /** The sub-directory where crashpad dumps can be found */\n  private readonly _crashpadSubDirectory: string;\n\n  /** List of minidumps that have been found already. */\n  private readonly _knownPaths: string[];\n\n  /** The directory Electron stores crashes in. */\n  private readonly _crashesDirectory: string;\n\n  /** A persistent directory to cache minidumps. */\n  private readonly _cacheDirectory: string;\n\n  /**\n   * Store to persist queued Minidumps beyond application crashes or lost\n   * internet connection.\n   */\n  private readonly _queue: Store<MinidumpRequest[]>;\n\n  /**\n   * Creates a new uploader instance.\n   *\n   * @param dsn The Sentry DSN.\n   * @param crashesDirectory The directory Electron stores crashes in.\n   * @param cacheDirectory A persistent directory to cache minidumps.\n   */\n  public constructor(dsn: Dsn, crashesDirectory: string, cacheDirectory: string) {\n    const crashpadWindows = process.platform === 'win32' && parseInt(process.versions.electron.split('.')[0], 10) >= 6;\n    this._type = process.platform === 'darwin' || crashpadWindows ? 'crashpad' : 'breakpad';\n    this._crashpadSubDirectory = process.platform === 'darwin' ? 'completed' : 'reports';\n    this._knownPaths = [];\n\n    this._url = MinidumpUploader.minidumpUrlFromDsn(dsn);\n    this._crashesDirectory = crashesDirectory;\n    this._cacheDirectory = cacheDirectory;\n    this._queue = new Store(this._cacheDirectory, 'queue', []);\n  }\n\n  /**\n   * Returns the minidump endpoint in Sentry\n   * @param dsn Dsn\n   */\n  public static minidumpUrlFromDsn(dsn: Dsn): string {\n    const { host, path, projectId, port, protocol, user } = dsn;\n    return `${protocol}://${host}${port !== '' ? `:${port}` : ''}${\n      path !== '' ? `/${path}` : ''\n    }/api/${projectId}/minidump?sentry_key=${user}`;\n  }\n\n  /**\n   * Uploads a minidump file to Sentry.\n   *\n   * @param path Absolute path to the minidump file.\n   * @param event Event data to attach to the minidump.\n   * @returns A promise that resolves when the upload is complete.\n   */\n  public async uploadMinidump(request: MinidumpRequest): Promise<void> {\n    logger.log('Uploading minidump', request.path);\n\n    try {\n      const body = new FormData();\n      body.append('upload_file_minidump', fs.createReadStream(request.path));\n      body.append('sentry', JSON.stringify(request.event));\n      const response = await fetch(this._url, { method: 'POST', body });\n\n      // Too many requests, so we queue the event and send it later\n      if (response.status === CODE_RETRY) {\n        await this._queueMinidump(request);\n      }\n\n      // We either succeeded or something went horribly wrong. Either way, we\n      // can remove the minidump file.\n      try {\n        await unlink(request.path);\n      } catch (e) {\n        logger.warn('Could not delete', request.path);\n      }\n\n      // Forget this minidump in all caches\n      // tslint:disable-next-line: strict-comparisons\n      this._queue.update(queued => queued.filter(stored => stored !== request));\n      this._knownPaths.splice(this._knownPaths.indexOf(request.path), 1);\n\n      // If we were successful, we can try to flush the remaining queue\n      if (response.ok) {\n        await this.flushQueue();\n      }\n    } catch (err) {\n      logger.warn('Failed to upload minidump', err);\n\n      // User's internet connection was down so we queue it as well\n      const error = err ? (err as { code: string }) : { code: '' };\n      if (error.code === 'ENOTFOUND') {\n        await this._queueMinidump(request);\n      }\n    }\n  }\n\n  /**\n   * Helper to filter an array with asynchronous callbacks.\n   *\n   * @param array An array containing items to filter.\n   * @param predicate An async predicate evaluated on every item.\n   * @param thisArg Optional value passed as \"this\" into the callback.\n   * @returns An array containing only values where the callback returned true.\n   */\n  private async _filterAsync<T>(\n    array: T[],\n    predicate: (item: T) => Promise<boolean> | boolean,\n    thisArg?: any,\n  ): Promise<T[]> {\n    const verdicts = await Promise.all(array.map(predicate, thisArg));\n    return array.filter((_, index) => verdicts[index]);\n  }\n\n  /**\n   * Searches for new, unknown minidump files in the crash directory.\n   * @returns A promise that resolves to absolute paths of those dumps.\n   */\n  public async getNewMinidumps(): Promise<string[]> {\n    const minidumps = this._type === 'crashpad' ? await this._scanCrashpadFolder() : await this._scanBreakpadFolder();\n    logger.log(`Found ${minidumps.length} minidumps`);\n\n    const oldestMs = new Date().getTime() - MAX_AGE * 24 * 3600 * 1000;\n    return this._filterAsync(minidumps, async path => {\n      // Skip files that we have seen before\n      if (this._knownPaths.indexOf(path) >= 0) {\n        return false;\n      }\n\n      // Lock this minidump until we have uploaded it or an error occurs and we\n      // remove it from the file system.\n      this._knownPaths.push(path);\n\n      // We do not want to upload minidumps that have been generated before a\n      // certain threshold. Those old files can be deleted immediately.\n      const stats = await stat(path);\n      if (stats.birthtimeMs < oldestMs) {\n        try {\n          await unlink(path);\n        } catch (e) {\n          logger.warn('Could not delete', path);\n        }\n        this._knownPaths.splice(this._knownPaths.indexOf(path), 1);\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  /** Flushes locally cached minidumps from the queue. */\n  public async flushQueue(): Promise<void> {\n    await Promise.all(this._queue.get().map(async request => this.uploadMinidump(request)));\n  }\n\n  /** Scans the Crashpad directory structure for minidump files. */\n  private async _scanCrashpadFolder(): Promise<string[]> {\n    // Crashpad moves minidump files directly into the 'completed' or 'reports' folder. We can\n    // load them from there, upload to the server, and then delete it.\n    const dumpDirectory = join(this._crashesDirectory, this._crashpadSubDirectory);\n    const files = await readdir(dumpDirectory);\n    return files.filter(file => file.endsWith('.dmp')).map(file => join(dumpDirectory, file));\n  }\n\n  /** Scans the Breakpad directory structure for minidump files. */\n  private async _scanBreakpadFolder(): Promise<string[]> {\n    // Breakpad stores all minidump files along with a metadata file directly in\n    // the crashes directory.\n    const files = await readdir(this._crashesDirectory);\n\n    // Remove all metadata files and forget about them.\n    // tslint:disable-next-line: no-floating-promises\n    Promise.all(\n      files\n        .filter(file => file.endsWith('.txt') && !file.endsWith('log.txt'))\n        .map(async file => {\n          const path = join(this._crashesDirectory, file);\n          try {\n            await unlink(path);\n          } catch (e) {\n            logger.warn('Could not delete', path);\n          }\n        }),\n    );\n\n    return files.filter(file => file.endsWith('.dmp')).map(file => join(this._crashesDirectory, file));\n  }\n\n  /**\n   * Enqueues a minidump with event information for later upload.\n   * @param request The request containing a minidump and event info.\n   */\n  private async _queueMinidump(request: MinidumpRequest): Promise<void> {\n    const filename = basename(request.path);\n\n    // Only enqueue if this minidump hasn't been enqueued before. Compare the\n    // filename instead of the full path, because we will move the file to a\n    // temporary location later on.\n    if (this._queue.get().some(req => basename(req.path) === filename)) {\n      return;\n    }\n\n    // Move the minidump file to a separate cache directory and enqueue it. Even\n    // if the Electron CrashReporter's cache directory gets wiped or changes,\n    // this will allow us to retry uploading the file later.\n    const queuePath = join(this._cacheDirectory, filename);\n    await mkdirp(this._cacheDirectory);\n    await rename(request.path, queuePath);\n\n    // Remove stale minidumps in case we go over limit. Note that we have to\n    // re-fetch the queue as it might have changed in the meanwhile. It is\n    // important to store the queue value again immediately to avoid phantom\n    // reads.\n    const requests = [...this._queue.get(), { ...request, path: queuePath }];\n    const stale = requests.splice(-MAX_REQUESTS_COUNT);\n    this._queue.set(requests);\n\n    await Promise.all(\n      stale.map(async req => {\n        try {\n          await unlink(req.path);\n        } catch (e) {\n          logger.warn('Could not delete', req.path);\n        }\n      }),\n    );\n  }\n}\n"]}