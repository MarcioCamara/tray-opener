Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@sentry/core");
const backend_1 = require("@sentry/node/dist/backend");
const types_1 = require("@sentry/types");
const utils_1 = require("@sentry/utils");
const electron_1 = require("electron");
const path_1 = require("path");
const common_1 = require("../common");
const sdk_1 = require("../sdk");
const normalize_1 = require("./normalize");
const store_1 = require("./store");
const net_1 = require("./transports/net");
const uploader_1 = require("./uploader");
/** Gets the path to the Sentry cache directory. */
function getCachePath() {
    return path_1.join(electron_1.app.getPath('userData'), 'sentry');
}
/**
 * Retruns a promise that resolves when app is ready.
 */
function isAppReady() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return (electron_1.app.isReady() ||
            // tslint:disable-next-line: no-promise-as-boolean
            new Promise(resolve => {
                electron_1.app.once('ready', resolve);
            }));
    });
}
exports.isAppReady = isAppReady;
/** Backend implementation for Electron renderer backends. */
class MainBackend extends core_1.BaseBackend {
    /** Creates a new Electron backend instance. */
    constructor(options) {
        super(options);
        this._inner = new backend_1.NodeBackend(options);
        this._scopeStore = new store_1.Store(getCachePath(), 'scope_v2', new core_1.Scope());
        let success = true;
        // The setImmediate is important here since the client has to be on the hub already that configureScope works
        setImmediate(() => {
            this._rehydrateScope();
            this._setupScopeListener();
        });
        if (this._isNativeEnabled()) {
            success = this._installNativeHandler() && success;
        }
        this._installIPC();
    }
    /**
     * Setup Transport
     */
    _setupTransport() {
        if (!this._options.dsn) {
            // We return the noop transport here in case there is no Dsn.
            return super._setupTransport();
        }
        const transportOptions = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this._options.transportOptions), (this._options.httpProxy && { httpProxy: this._options.httpProxy })), (this._options.httpsProxy && { httpsProxy: this._options.httpsProxy })), (this._options.caCerts && { caCerts: this._options.caCerts })), { dsn: this._options.dsn });
        if (this._options.transport) {
            return new this._options.transport(transportOptions);
        }
        return new net_1.NetTransport(transportOptions);
    }
    /**
     * @inheritDoc
     */
    eventFromException(exception, hint) {
        return this._inner.eventFromException(exception, hint);
    }
    /**
     * @inheritDoc
     */
    eventFromMessage(message, level = types_1.Severity.Info, hint) {
        return this._inner.eventFromMessage(message, level, hint);
    }
    /**
     * Uploads the given minidump and attaches event information.
     *
     * @param path A relative or absolute path to the minidump file.
     * @param event Optional event information to add to the minidump request.
     */
    uploadMinidump(path, event = {}) {
        if (this._uploader) {
            utils_1.forget(this._uploader.uploadMinidump({ path, event }));
        }
    }
    /**
     * Loads the stored scope from disk ands sets it int the current scope
     */
    _rehydrateScope() {
        // We refill the scope here to not have an empty one
        core_1.configureScope(scope => {
            // tslint:disable:no-unsafe-any
            const loadedScope = core_1.Scope.clone(this._scopeStore.get());
            if (loadedScope._user) {
                scope.setUser(loadedScope._user);
            }
            scope.setTags(loadedScope._tags);
            scope.setExtras(loadedScope._extra);
            if (loadedScope._breadcrumbs) {
                loadedScope._breadcrumbs.forEach((crumb) => {
                    scope.addBreadcrumb(crumb);
                });
            }
            // tslint:enable:no-unsafe-any
        });
    }
    /**
     * Adds a scope listener to persist changes to disk.
     */
    _setupScopeListener() {
        const hubScope = core_1.getCurrentHub().getScope();
        if (hubScope) {
            hubScope.addScopeListener(updatedScope => {
                const cloned = core_1.Scope.clone(updatedScope);
                cloned._eventProcessors = [];
                cloned._scopeListeners = [];
                // tslint:disable-next-line:no-object-literal-type-assertion
                this._scopeStore.update((current) => (Object.assign(Object.assign({}, current), cloned)));
            });
        }
    }
    /** Returns whether native reports are enabled. */
    _isNativeEnabled() {
        // Mac AppStore builds cannot run the crash reporter due to the sandboxing
        // requirements. In this case, we prevent enabling native crashes entirely.
        // https://electronjs.org/docs/tutorial/mac-app-store-submission-guide#limitations-of-mas-build
        if (process.mas) {
            return false;
        }
        return this._options.enableNative !== false;
    }
    /** Activates the Electron CrashReporter. */
    _installNativeHandler() {
        // We are only called by the frontend if the SDK is enabled and a valid DSN
        // has been configured. If no DSN is present, this indicates a programming
        // error.
        const dsnString = this._options.dsn;
        if (!dsnString) {
            throw new utils_1.SentryError('Invariant exception: install() must not be called when disabled');
        }
        const dsn = new utils_1.Dsn(dsnString);
        // We will manually submit errors, but CrashReporter requires a submitURL in
        // some versions. Also, provide a productName and companyName, which we will
        // add manually to the event's context during submission.
        electron_1.crashReporter.start({
            companyName: '',
            ignoreSystemCrashHandler: true,
            productName: this._options.appName || common_1.getNameFallback(),
            submitURL: uploader_1.MinidumpUploader.minidumpUrlFromDsn(dsn),
            uploadToServer: false,
        });
        // The crashReporter has an undocumented method to retrieve the directory
        // it uses to store minidumps in. The structure in this directory depends
        // on the crash library being used (Crashpad or Breakpad).
        const reporter = electron_1.crashReporter;
        const crashesDirectory = reporter.getCrashesDirectory();
        this._uploader = new uploader_1.MinidumpUploader(dsn, crashesDirectory, getCachePath());
        // Flush already cached minidumps from the queue.
        utils_1.forget(this._uploader.flushQueue());
        // Start to submit recent minidump crashes. This will load breadcrumbs and
        // context information that was cached on disk prior to the crash.
        utils_1.forget(this._sendNativeCrashes({}));
        // Every time a subprocess or renderer crashes, start sending minidumps
        // right away.
        electron_1.app.on('web-contents-created', (_, contents) => {
            contents.on('crashed', () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                try {
                    yield this._sendNativeCrashes(this._getRendererExtra(contents));
                }
                catch (e) {
                    console.error(e);
                }
                core_1.addBreadcrumb({
                    category: 'exception',
                    level: types_1.Severity.Critical,
                    message: 'Renderer Crashed',
                    timestamp: new Date().getTime() / 1000,
                });
            }));
            if (this._options.enableUnresponsive !== false) {
                contents.on('unresponsive', () => {
                    core_1.captureMessage('BrowserWindow Unresponsive');
                });
            }
        });
        return true;
    }
    /** Installs IPC handlers to receive events and metadata from renderers. */
    _installIPC() {
        electron_1.ipcMain.on(common_1.IPC_PING, (event) => {
            event.sender.send(common_1.IPC_PING);
        });
        electron_1.ipcMain.on(common_1.IPC_EVENT, (ipc, event) => {
            event.extra = Object.assign(Object.assign({}, this._getRendererExtra(ipc.sender)), event.extra);
            core_1.captureEvent(event);
        });
        electron_1.ipcMain.on(common_1.IPC_SCOPE, (_, rendererScope) => {
            // tslint:disable:no-unsafe-any
            const sentScope = core_1.Scope.clone(rendererScope);
            core_1.configureScope(scope => {
                if (sentScope._user) {
                    scope.setUser(sentScope._user);
                }
                scope.setTags(sentScope._tags);
                scope.setExtras(sentScope._extra);
                // Since we do not have updates for individual breadcrumbs anymore and only for the whole scope
                // we just add the last added breadcrumb on scope updates
                scope.addBreadcrumb(sentScope._breadcrumbs.pop());
            });
            // tslint:enable:no-unsafe-any
        });
    }
    /** Loads new native crashes from disk and sends them to Sentry. */
    _sendNativeCrashes(extra) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Whenever we are called, assume that the crashes we are going to load down
            // below have occurred recently. This means, we can use the same event data
            // for all minidumps that we load now. There are two conditions:
            //
            //  1. The application crashed and we are just starting up. The stored
            //     breadcrumbs and context reflect the state during the application
            //     crash.
            //
            //  2. A renderer process crashed recently and we have just been notified
            //     about it. Just use the breadcrumbs and context information we have
            //     right now and hope that the delay was not too long.
            const uploader = this._uploader;
            if (uploader === undefined) {
                throw new utils_1.SentryError('Invariant violation: Native crashes not enabled');
            }
            const currentCloned = core_1.Scope.clone(core_1.getCurrentHub().getScope());
            const fetchedScope = this._scopeStore.get();
            try {
                const storedScope = core_1.Scope.clone(fetchedScope);
                let newEvent = yield storedScope.applyToEvent({ extra });
                if (newEvent) {
                    newEvent = yield currentCloned.applyToEvent(newEvent);
                    const paths = yield uploader.getNewMinidumps();
                    paths.map(path => {
                        sdk_1.captureMinidump(path, Object.assign({}, newEvent));
                    });
                }
            }
            catch (_oO) {
                utils_1.logger.error('Error while sending native crash.');
            }
        });
    }
    /** Returns extra information from a renderer's web contents. */
    _getRendererExtra(contents) {
        const customName = this._options.getRendererName && this._options.getRendererName(contents);
        return {
            crashed_process: customName || `renderer[${contents.id}]`,
            crashed_url: normalize_1.normalizeUrl(contents.getURL()),
        };
    }
}
exports.MainBackend = MainBackend;
//# sourceMappingURL=backend.js.map